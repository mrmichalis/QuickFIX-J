/*******************************************************************************
 * Copyright (c) quickfixengine.org  All rights reserved. 
 * 
 * This file is part of the QuickFIX FIX Engine 
 * 
 * This file may be distributed under the terms of the quickfixengine.org 
 * license as defined by quickfixengine.org and appearing in the file 
 * LICENSE included in the packaging of this file. 
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING 
 * THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE. 
 * 
 * See http://www.quickfixengine.org/LICENSE for licensing information. 
 * 
 * Contact ask@quickfixengine.org if any conditions of this licensing 
 * are not clear to you.
 ******************************************************************************/

package quickfix;

import java.io.IOException;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;

/**
 * Used by the session communications code. Not intended to be used by
 * applications.
 */
public class SessionState {
    private final Log log;
    private final MessageStore messageStore;

    // NEED Synchronized access
    private final HashMap messageQueue = new HashMap();
    private int[] resendRange = new int[] { 0, 0 };

    // Make final if possible
    private volatile long logonTimeoutMs = 10000L;
    private volatile long logoutTimeoutMs = 2000L;

    private volatile long heartBeatIntervalMillis;
    private volatile boolean logonSent;
    private volatile boolean logonReceived;
    private volatile boolean logoutSent;
    private volatile boolean logoutReceived = false;
    private volatile int testRequestCounter;
    private volatile long lastSentTime;
    private volatile long lastReceivedTime;
    private volatile boolean withinHeartBeat;
    private volatile boolean resetSent;
    private volatile boolean resetReceived;
    private volatile String logoutReason;

    public SessionState(Log stateLogger, long heartBeatIntervalMillis, MessageStore messageStore) {
        this.log = stateLogger != null ? stateLogger : new NullLog();
        this.heartBeatIntervalMillis = heartBeatIntervalMillis;
        this.messageStore = messageStore;
    }

    // TODO Is this really needed? See Session usage...
    public long getHeartBeatIntervalMillis() {
        return heartBeatIntervalMillis;
    }

    public int getHeartBeatInterval() {
        return (int)Math.floor(heartBeatIntervalMillis / 1000.0);
    }

    public boolean isHeartBeatNeeded() {
        long millisSinceLastSentTime = SystemTime.currentTimeMillis() - getLastSentTime();
        return millisSinceLastSentTime >= heartBeatIntervalMillis && getTestRequestCounter() == 0;
    }

    public boolean isInitiator() {
        return heartBeatIntervalMillis != 0;
    }

    public long getLastReceivedTime() {
        return lastReceivedTime;
    }

    public void setLastReceivedTime(long lastReceivedTime) {
        this.lastReceivedTime = lastReceivedTime;
    }

    public long getLastSentTime() {
        return lastSentTime;
    }

    public void setLastSentTime(long lastSentTime) {
        this.lastSentTime = lastSentTime;
    }

    public boolean isLogonAlreadySent() {
        return isInitiator() && isLogonSent();
    }

    public boolean isLogonReceived() {
        return logonReceived;
    }

    public void setLogonReceived(boolean logonReceived) {
        this.logonReceived = logonReceived;
    }

    public boolean isLogonSendNeeded() {
        return isInitiator() && !isLogonSent();
    }

    public boolean isLogonSent() {
        return logonSent;
    }

    public void setLogonSent(boolean logonSent) {
        this.logonSent = logonSent;
    }

    public boolean isLogonTimedOut() {
        return SystemTime.currentTimeMillis() - getLastReceivedTime() >= logonTimeoutMs;
    }

    public void setLogonTimeout(int logonTimeout) {
        this.logonTimeoutMs = logonTimeout * 1000L;
    }

    public void setLogoutTimeout(int logoutTimeout) {
        this.logoutTimeoutMs = logoutTimeout * 1000L;
    }

    public boolean isLogoutSent() {
        return logoutSent;
    }

    public void setLogoutSent(boolean logoutSent) {
        this.logoutSent = logoutSent;
    }

    public boolean isLogoutReceived() {
        return logoutReceived;
    }

    public void setLogoutReceived(boolean logoutReceived) {
        this.logoutReceived = logoutReceived;
    }

    public boolean isLogoutTimedOut() {
        return isLogoutSent()
                && ((SystemTime.currentTimeMillis() - getLastSentTime()) >= logoutTimeoutMs);
    }

    public MessageStore getMessageStore() {
        return messageStore;
    }

    public int getTestRequestCounter() {
        return testRequestCounter;
    }

    public void clearTestRequestCounter() {
        testRequestCounter = 0;
    }

    public synchronized void incrementTestRequestCounter() {
        testRequestCounter++;
    }

    public boolean isTestRequestNeeded() {
        long millisSinceLastReceivedTime = timeSinceLastReceivedMessage();
        return millisSinceLastReceivedTime >= (1.5 * (testRequestCounter + 1))
                * heartBeatIntervalMillis;
    }

    private long timeSinceLastReceivedMessage() {
        return SystemTime.currentTimeMillis() - lastReceivedTime;
    }

    public boolean isTimedOut() {
        long millisSinceLastReceivedTime = timeSinceLastReceivedMessage();
        return millisSinceLastReceivedTime >= 2.4 * heartBeatIntervalMillis;
    }

    public boolean isWithinHeartBeat() {
        return withinHeartBeat;
    }

    public boolean set(int sequence, String message) throws IOException {
        return messageStore.set(sequence, message);
    }

    public void get(int first, int last, Collection messages) throws IOException {
        messageStore.get(first, last, messages);
    }

    public int getNextSenderMsgSeqNum() throws IOException {
        return messageStore.getNextSenderMsgSeqNum();
    }

    public int getNextTargetMsgSeqNum() throws IOException {
        return messageStore.getNextTargetMsgSeqNum();
    }

    public void setNextTargetMsgSeqNum(int sequence) throws IOException {
        messageStore.setNextTargetMsgSeqNum(sequence);
    }

    public void incrNextSenderMsgSeqNum() throws IOException {
        messageStore.incrNextSenderMsgSeqNum();
    }

    public void incrNextTargetMsgSeqNum() throws IOException {
        messageStore.incrNextTargetMsgSeqNum();
    }

    public Date getCreationTime() throws IOException {
        return messageStore.getCreationTime();
    }

    public void reset() {
        try {
            messageStore.reset();
        } catch (IOException e) {
            throw new RuntimeError(e);
        }
    }

    public void enqueue(int sequence, Message message) {
        synchronized (messageQueue) {
            messageQueue.put(new Integer(sequence), message);
        }
    }

    public Message dequeue(int sequence) {
        synchronized (messageQueue) {
            return (Message) messageQueue.get(new Integer(sequence));
        }
    }

    public void clearQueue() {
        synchronized (messageQueue) {
            messageQueue.clear();
        }
    }

    public void setResendRange(int low, int high) {
        synchronized (resendRange) {
            resendRange[0] = low;
            resendRange[1] = high;
        }
    }

    public boolean isResendRequested() {
        synchronized (resendRange) {
            return !(resendRange[0] == 0 && resendRange[1] == 0);
        }
    }

    public int[] getResendRange() {
        synchronized (resendRange) {
            return resendRange;
        }
    }

    public boolean isResetReceived() {
        return resetReceived;
    }

    public void setResetReceived(boolean resetReceived) {
        this.resetReceived = resetReceived;
    }

    public boolean isResetSent() {
        return resetSent;
    }

    public void setResetSent(boolean resetSent) {
        this.resetSent = resetSent;
    }

    public void setLogoutReason(String reason) {
        logoutReason = reason;
    }

    public String getLogoutReason() {
        return logoutReason;
    }

    public void clearLogoutReason() {
        logoutReason = "";
    }

    public Log getLog() {
        return log;
    }

    private final class NullLog implements Log {
        public void onOutgoing(String message) {
        }

        public void onIncoming(String message) {
        }

        public void onEvent(String text) {
        }

        public void clear() {
        }
    }

    public void setHeartBeatInterval(long heartBeatIntervalMillis) {
        this.heartBeatIntervalMillis = heartBeatIntervalMillis;
    }
}